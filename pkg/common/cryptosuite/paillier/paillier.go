package paillier

import (
	"github.com/cronokirby/saferith"
	"github.com/mr-shifu/mpc-lib/core/math/arith"
	pailliercore "github.com/mr-shifu/mpc-lib/core/paillier"
	"github.com/mr-shifu/mpc-lib/pkg/common/cryptosuite/pedersen"
)

type PaillierKeyManager interface {
	// GenerateKey generates a new Paillier key pair.
	GenerateKey() (PaillierKey, error)

	// Derive Pedersen Key from Paillier Key prime factors
	DerivePedersenKey(ski []byte) (pedersen.PedersenKey, error)

	// GetKey returns a Paillier key by its SKI.
	GetKey(ski []byte) (PaillierKey, error)

	// ImportKey imports a Paillier key from its byte representation.
	ImportKey(key PaillierKey) error

	// Encrypt returns the encryption of `message` as ciphertext and nonce generated by function.
	Encode(ski []byte, m *saferith.Int) (*pailliercore.Ciphertext, *saferith.Nat)

	// EncryptWithNonce returns the encryption of `message` as ciphertext and nonce passed to function.
	EncWithNonce(ski []byte, m *saferith.Int, nonce *saferith.Nat) *pailliercore.Ciphertext

	// Decrypt returns the decryption of `ct` as ciphertext.
	Decode(ski []byte, ct *pailliercore.Ciphertext) (*saferith.Int, error)

	// DecryptWithNonce returns the decryption of `ct` as ciphertext and nonce.
	DecodeWithNonce(ski []byte, ct *pailliercore.Ciphertext) (*saferith.Int, error)

	// ValidateCiphertexts returns true if all ciphertexts are valid.
	ValidateCiphertexts(ski []byte, cts ...*pailliercore.Ciphertext) bool
}

type PaillierKey interface {
	// Bytes returns the byte representation of the key.
	Bytes() ([]byte, error)

	// SKI returns the serialized key identifier.
	SKI() []byte

	// Private returns true if the key is private.
	Private() bool

	// PublicKey returns the corresponding public key part of Elgamal Key.
	PublicKey() PaillierKey

	// Modulus returns an arith.Modulus for N.
	Modulus() *arith.Modulus

	// ParamN returns the public key modulus N.
	ParamN() *saferith.Modulus
}
